---
type: "post"
title: "《区块链技术与应用》公开课笔记"
author: "horizon"
category: "Tech"
date: "2025-03-19"
slug: "/Tech_14"
postImage: "./img/Tech_14.jpg"
metaDescription: "记录了《区块链技术与应用》公开课的笔记。包含密码学原理、数据结构、比特币中的共识协议、比特币系统的具体实现等内容。"
---

## 02 密码学原理

0. 比特币用到了密码学的哪些原理？哈希和签名

1. collision resistance:没有什么高效的方法、去找到两个哈希值相同的输入

   - 用途：监测文件是否被篡改
   - MD5：可以人为制造碰撞，不安全了

1. hiding: 哈希函数的计算过程是单向的，不可逆的

   - 哈希值没有泄露有关输入的任何信息
   - 成立前提：输入的空间要足够大，同时取值要均匀

1. digital commitment: 将 collision resistance 和 hiding 结合起来

   - 用途：数字签名
   - 即是：预测结果不能提前公开（sealed envelope，将预测结果交给第三方保存），可以将哈希值公布出去，等到结果公布时，再公布输入

1. 实践时候：X||nonce，nonce 是随机数，X 是输入，这样保证了足够随机

1. puzzle friendly：哈希值的计算是事先不可预测的

   - 就是不能够知道哪些输入会产生前缀为固定的哈希值，比如预测前缀为 00000 的哈希值，不能提前知道哪些输入会产生这样的哈希值
   - 应用：挖矿的过程没有捷径、所以挖矿的币可以作为工作量证明
   - 但是验证挖矿的结果是很容易的，只需要验证哈希值是否满足条件即可（difficult to find, easy to verify）

1. SHA-256：比特币中使用的哈希函数（Secure Hash Algorithm 256 bits）

1. 哈希讲完了、下面讲签名

1. 首先讲比特币的账户管理

   - 开户的时候，会生成一对公私钥，公钥是地址，私钥是签名（很简单、是去中心化的）
   - 是非对称的加密（asymmetric cryptography），公钥加密私钥解密（用的是同一个人的公钥加密和私钥解密，接收方的）
   - 公钥公开、私钥保存在本地就可以了

1. 别人怎么知道这个发起交易的人的真实性呢、就是发起交易的时候、用私钥加密、然后其他人用公钥解密（也是同一个人的）

1. 生成公私钥的过程需要有好的随机源，否则会有安全隐患

1. 一般是对 message 取一个 hash、然后再对这个 hash 进行签名

## 03 数据结构

1. 哈希指针 hash pointers

   - 除了保存了数据的地址，还保存了数据的哈希值

2. 区块链和普通链表的区别

   - 用哈希指针代替了普通链表的指针
   - 第一个区块叫做 genesis block，最近的区块叫做 most recent block
   - 每个后继的区块都保存了指向前驱区块的哈希指针

3. 区块链的结构能够实现 tamper-evident log

   - 任何一个区块的数据被篡改，那么这个区块的哈希值就会发生变化，那么这个区块的哈希指针就会发生变化，那么这个区块的后继区块的哈希指针也会发生变化，以此类推，整个区块链的哈希指针都会发生变化
   - 所以我只要保存了最后一个区块的哈希值，就可以验证整个区块链的完整性（即验证这个区块链是否发生变化）
   - 怎么知道别人给你的区块是不是正确的、只需要算一下哈希值就可以了

4. merkle tree 和 binary tree 的区别

   - 用哈希指针代替了普通树的指针
   - 最下面的一层是数据块（data blocks）
   - 中间的几层都是 hash pointers
   - 根节点也可以再取一个 hash（root hash）
   - 用途：只需要保存 root hash、就可以监测出树中的任何位置的数据是否被篡改（因为若修改了、hash 会从数据块一层层向上传递到根节点）

5. data blocks 每一个其实相当于一个交易 transaction（tx）

   - 每一个 block 可以分为
   - block header：包含了前一个区块的哈希值、merkle root
   - block body：包含了多个交易（交易的列表）

6. merkle tree 的一个用途就是提供 merkle proof

7. 节点一共有 2 类：

   - full node（全节点）：保存了 block headers 和 block bodies（有交易的具体信息）
   - light node（轻节点）：只保存了 block headers

8. 怎么给一个 light node 提供 merkle proof

   - proof 的本质：找到交易所在的位置，然后提供一条从这个位置到根节点的路径
   - （这个路径上的哈希值都是已知的，所以 light node 可以验证这个路径上的哈希值是否正确，从而验证这个交易是否在这个区块中）（这个就是 merkle proof）
   - 具体流程：给一个全节点发送一个请求，请求这个交易所在的位置，然后全节点返回这个路径给 light node（路径上的哈希值计算：每个全节点保存了 2 个哈希值（即左子树的哈希值和右子树的哈希值），路径上会涉及到向全节点请求的哈希值（红色），以及 SPV 本地计算的哈希值（绿色），每一层、通过当前层自己计算的哈希值结合请求来的哈希值在一起、就可以计算出父节点的哈希值、一直到根节点。（一开始的交易哈希值、是通过交易节点在本地计算的）
   - 注意：只能查交易路径上的哈希值、旁边分支的哈希值是不能查的
   - 原理：因为树里的任意一个位置的哈希值更改之后、都会影响到根哈希值
   - 这种交易也叫做 proof of inclusion（membership）

9. 如何高效地证明 proof of non-membership?

   - 如果对叶节点的顺序不做一些假设、那么就没有很好的方法
   - 如果有顺序的话、可以用 binary search（log(n)，但是代价就是要排序）（方法：证明和其兄弟的数据节点能验证这个 root hash 的值）（sorted merkle tree）（比特币中没有用到、因为没有这个需求）

10. 只要这个数据结构是无环的、都可以用哈希指针来代替（有环就不可以，因为会有循环依赖的问题）

## 04 比特币中的共识协议

1. 不能直接地像现实世界中的一样、通过中心化的方式去发行货币、否则会有 double spending attack 的问题（就是可以复制这个发行的货币）（也可以通过央行维护一个数据库去解决，但是这个方案太麻烦了、是个中心化的方案，每一次交易都需要通过央行进行监管）

2. 两个问题：

   - 如何发行货币
   - 如何证明交易的有效性

3. 比特币的解决方案（证明交易的有效性）：

   - 通过所有用户来维护
   - 例子：铸币交易<--花费交易
   - 每个交易都包含输入和输出两部分，输入部分要说明币的来源（签名者，以及多层级的哈希指针、比如指向前面某个交易的哈希指针，证明这个币不是凭空捏造的、而且要避免 double spending，可以通过哈希指针的方式去判断是否合法）。输出部分要给出收款人公钥的哈希

4. Block header

   - 包含了区块中的宏观的信息（比如哪个协议） version
   - 区块链中指向前一个区块的哈希指针（取哈希的时候是把所有的 block header 都取哈希就足够了）
   - 整棵 merkle tree 的根哈希值 root hash
   - 挖矿的难度目标阈值（target）
   - 随机数 nonce

5. Block body

   - 交易列表 transaction list

6. 系统中的节点分为全节点和轻节点

   - 全节点：保存了所有的区块链数据（验证每一个交易的有效性）（也叫 fully validating node）
   - 轻节点：只保存了区块链的头部信息（没有办法独立验证交易的有效性）（系统中的大部分节点都是轻节点）（没有参与区块链的构造与维护）

7. 账本的内容要取得分布式的共识（distributed consensus）

   - 例子：分布式哈希表（distributed hash table）

8. FLP impossibility theorem：在异步系统中、有一个节点失效、就不能保证达成共识

9. CAP theorem：在分布式系统中、不能同时满足一致性（consistency）、可用性（availability）、分区容忍性（partition tolerance）

10. Paxos：一个分布式共识算法（CSE 讲过）（但是与比特币的实际应用关系不大）

11. 比特币中的共识协议（Consensus in BitCoin）

    - 假定系统中的大多数节点都是好的，有一小部分节点是恶意的
    - membership：投票权的问题

12. sybil attack（女巫攻击）：恶意节点可以通过伪造身份来获得更多的投票权（所以简单投票是不行的，因为谁都能创造账户）

13. 所以比特币是基于算力进行投票的

    - 需要验证 H(block header) <= target

14. 这里会有一个问题、就是如果在同一个节点上插入两个区块、那么就会有分叉的问题

    - 为了解决这个问题、需要选择最长且合法的链（longest valid chain）
    - 例子：比如说想要通过插入一个自我转账的区块（用于回滚交易），虽然这个区块在一开始检查的时候是合法的，但是不在最长的链上，所以是无效的（因为验证区块有效性的时候、只会去证明在这个分支链上的交易是否有效）（这个就是 forking attack）

15. 如果有两个节点同时或者在差不多的时间找到一个 nonce、那么也会有分叉的问题

    - 这时候会同时产生两个节点
    - 解决方法：各个节点接受第一个收到的区块（接受：即往下扩展一个区块）（相当于各拉一帮人，然后看谁先找到下一个，通过算力竞争或者运气先算到）
    - 所以会维持一段时间，直到最后有一个节点找到下一个区块，然后就会胜出，失败的就叫做 orphaned block

16. 为什么要消耗很多资源去获得记账权：有记账权节点有一定权力、可以决定哪些节点能写到下一个区块里

    - 但是初衷是应该所有合法的交易都应该被写到区块链上，不应该让这个成为争夺记账权的主要动力
    - 解决方法：出块奖励（block reward）获得记账权的节点、在发布的区块里可以有一个特殊的交易，即铸币交易（coinbase transaction）在这个交易里，可以发布一定数量的比特币（比特币系统中发布比特币的唯一途径，其他所有交易都是转账交易）
    - 最开始是 50 个比特币、每 210000 个区块减半

17. hash rate：得到记账权的节点的算力

18. 因此避免了 sybil attack ，创建账户并不会使得你有更多的记账权

19. 比特币争夺记账权的过程就是挖矿（mining），争夺记账权的节点叫做矿工（miner）

## 05 比特币系统的具体实现
