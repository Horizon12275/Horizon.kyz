---
type: "post"
title: "《区块链技术与应用》公开课笔记"
author: "horizon"
category: "Tech"
date: "2025-03-19"
slug: "/Tech_14"
postImage: "./img/Tech_14.jpg"
metaDescription: "记录了《区块链技术与应用》公开课的笔记。包含密码学原理、数据结构、比特币中的共识协议、比特币系统的具体实现等内容。"
---

## 02 密码学原理

0. 比特币用到了密码学的哪些原理？哈希和签名

1. collision resistance:没有什么高效的方法、去找到两个哈希值相同的输入

   - 用途：监测文件是否被篡改
   - MD5：可以人为制造碰撞，不安全了

1. hiding: 哈希函数的计算过程是单向的，不可逆的

   - 哈希值没有泄露有关输入的任何信息
   - 成立前提：输入的空间要足够大，同时取值要均匀

1. digital commitment: 将 collision resistance 和 hiding 结合起来

   - 用途：数字签名
   - 即是：预测结果不能提前公开（sealed envelope，将预测结果交给第三方保存），可以将哈希值公布出去，等到结果公布时，再公布输入

1. 实践时候：X||nonce，nonce 是随机数，X 是输入，这样保证了足够随机

1. puzzle friendly：哈希值的计算是事先不可预测的

   - 就是不能够知道哪些输入会产生前缀为固定的哈希值，比如预测前缀为 00000 的哈希值，不能提前知道哪些输入会产生这样的哈希值
   - 应用：挖矿的过程没有捷径、所以挖矿的币可以作为工作量证明
   - 但是验证挖矿的结果是很容易的，只需要验证哈希值是否满足条件即可（difficult to find, easy to verify）

1. SHA-256：比特币中使用的哈希函数（Secure Hash Algorithm 256 bits）

1. 哈希讲完了、下面讲签名

1. 首先讲比特币的账户管理

   - 开户的时候，会生成一对公私钥，公钥是地址，私钥是签名（很简单、是去中心化的）
   - 是非对称的加密（asymmetric cryptography），公钥加密私钥解密（用的是同一个人的公钥加密和私钥解密，接收方的）
   - 公钥公开、私钥保存在本地就可以了

1. 别人怎么知道这个发起交易的人的真实性呢、就是发起交易的时候、用私钥加密、然后其他人用公钥解密（也是同一个人的）

1. 生成公私钥的过程需要有好的随机源，否则会有安全隐患

1. 一般是对 message 取一个 hash、然后再对这个 hash 进行签名

## 03 数据结构

1. 哈希指针 hash pointers

   - 除了保存了数据的地址，还保存了数据的哈希值

2. 区块链和普通链表的区别

   - 用哈希指针代替了普通链表的指针
   - 第一个区块叫做 genesis block，最近的区块叫做 most recent block
   - 每个后继的区块都保存了指向前驱区块的哈希指针

3. 区块链的结构能够实现 tamper-evident log

   - 任何一个区块的数据被篡改，那么这个区块的哈希值就会发生变化，那么这个区块的哈希指针就会发生变化，那么这个区块的后继区块的哈希指针也会发生变化，以此类推，整个区块链的哈希指针都会发生变化
   - 所以我只要保存了最后一个区块的哈希值，就可以验证整个区块链的完整性（即验证这个区块链是否发生变化）
   - 怎么知道别人给你的区块是不是正确的、只需要算一下哈希值就可以了

4. merkle tree 和 binary tree 的区别

   - 用哈希指针代替了普通树的指针
   - 最下面的一层是数据块（data blocks）
   - 中间的几层都是 hash pointers
   - 根节点也可以再取一个 hash（root hash）
   - 用途：只需要保存 root hash、就可以监测出树中的任何位置的数据是否被篡改（因为若修改了、hash 会从数据块一层层向上传递到根节点）

5. data blocks 每一个其实相当于一个交易 transaction（tx）

   - 每一个 block 可以分为
   - block header：包含了前一个区块的哈希值、merkle root
   - block body：包含了多个交易（交易的列表）

6. merkle tree 的一个用途就是提供 merkle proof

7. 节点一共有 2 类：

   - full node（全节点）：保存了 block headers 和 block bodies（有交易的具体信息）
   - light node（轻节点）：只保存了 block headers

8. 怎么给一个 light node 提供 merkle proof

   - proof 的本质：找到交易所在的位置，然后提供一条从这个位置到根节点的路径
   - （这个路径上的哈希值都是已知的，所以 light node 可以验证这个路径上的哈希值是否正确，从而验证这个交易是否在这个区块中）（这个就是 merkle proof）
   - 具体流程：给一个全节点发送一个请求，请求这个交易所在的位置，然后全节点返回这个路径给 light node（路径上的哈希值计算：每个全节点保存了 2 个哈希值（即左子树的哈希值和右子树的哈希值），路径上会涉及到向全节点请求的哈希值（红色），以及 SPV 本地计算的哈希值（绿色），每一层、通过当前层自己计算的哈希值结合请求来的哈希值在一起、就可以计算出父节点的哈希值、一直到根节点。（一开始的交易哈希值、是通过交易节点在本地计算的）
   - 注意：只能查交易路径上的哈希值、旁边分支的哈希值是不能查的
   - 原理：因为树里的任意一个位置的哈希值更改之后、都会影响到根哈希值
   - 这种交易也叫做 proof of inclusion（membership）

9. 如何高效地证明 proof of non-membership?

   - 如果对叶节点的顺序不做一些假设、那么就没有很好的方法
   - 如果有顺序的话、可以用 binary search（log(n)，但是代价就是要排序）（方法：证明和其兄弟的数据节点能验证这个 root hash 的值）（sorted merkle tree）（比特币中没有用到、因为没有这个需求）

10. 只要这个数据结构是无环的、都可以用哈希指针来代替（有环就不可以，因为会有循环依赖的问题）

## 04 比特币中的共识协议

1. 不能直接地像现实世界中的一样、通过中心化的方式去发行货币、否则会有 double spending attack 的问题（就是可以复制这个发行的货币）（也可以通过央行维护一个数据库去解决，但是这个方案太麻烦了、是个中心化的方案，每一次交易都需要通过央行进行监管）

2. 两个问题：

   - 如何发行货币
   - 如何证明交易的有效性

3. 比特币的解决方案（证明交易的有效性）：

   - 通过所有用户来维护
   - 例子：铸币交易<--花费交易
   - 每个交易都包含输入和输出两部分，输入部分要说明币的来源（签名者，以及多层级的哈希指针、比如指向前面某个交易的哈希指针，证明这个币不是凭空捏造的、而且要避免 double spending，可以通过哈希指针的方式去判断是否合法）。输出部分要给出收款人公钥的哈希

4. Block header

   - 包含了区块中的宏观的信息（比如哪个协议） version
   - 区块链中指向前一个区块的哈希指针（取哈希的时候是把所有的 block header 都取哈希就足够了）
   - 整棵 merkle tree 的根哈希值 root hash
   - 挖矿的难度目标阈值（target）
   - 随机数 nonce

5. Block body

   - 交易列表 transaction list

6. 系统中的节点分为全节点和轻节点

   - 全节点：保存了所有的区块链数据（验证每一个交易的有效性）（也叫 fully validating node）
   - 轻节点：只保存了区块链的头部信息（没有办法独立验证交易的有效性）（系统中的大部分节点都是轻节点）（没有参与区块链的构造与维护）

7. 账本的内容要取得分布式的共识（distributed consensus）

   - 例子：分布式哈希表（distributed hash table）

8. FLP impossibility theorem：在异步系统中、有一个节点失效、就不能保证达成共识

9. CAP theorem：在分布式系统中、不能同时满足一致性（consistency）、可用性（availability）、分区容忍性（partition tolerance）

10. Paxos：一个分布式共识算法（CSE 讲过）（但是与比特币的实际应用关系不大）

11. 比特币中的共识协议（Consensus in BitCoin）

    - 假定系统中的大多数节点都是好的，有一小部分节点是恶意的
    - membership：投票权的问题

12. sybil attack（女巫攻击）：恶意节点可以通过伪造身份来获得更多的投票权（所以简单投票是不行的，因为谁都能创造账户）

13. 所以比特币是基于算力进行投票的

    - 需要验证 H(block header) <= target

14. 这里会有一个问题、就是如果在同一个节点上插入两个区块、那么就会有分叉的问题

    - 为了解决这个问题、需要选择最长且合法的链（longest valid chain）
    - 例子：比如说想要通过插入一个自我转账的区块（用于回滚交易），虽然这个区块在一开始检查的时候是合法的，但是不在最长的链上，所以是无效的（因为验证区块有效性的时候、只会去证明在这个分支链上的交易是否有效）（这个就是 forking attack）

15. 如果有两个节点同时或者在差不多的时间找到一个 nonce、那么也会有分叉的问题

    - 这时候会同时产生两个节点
    - 解决方法：各个节点接受第一个收到的区块（接受：即往下扩展一个区块）（相当于各拉一帮人，然后看谁先找到下一个，通过算力竞争或者运气先算到）
    - 所以会维持一段时间，直到最后有一个节点找到下一个区块，然后就会胜出，失败的就叫做 orphaned block

16. 为什么要消耗很多资源去获得记账权：有记账权节点有一定权力、可以决定哪些节点能写到下一个区块里

    - 但是初衷是应该所有合法的交易都应该被写到区块链上，不应该让这个成为争夺记账权的主要动力
    - 解决方法：出块奖励（block reward）获得记账权的节点、在发布的区块里可以有一个特殊的交易，即铸币交易（coinbase transaction）在这个交易里，可以发布一定数量的比特币（比特币系统中发布比特币的唯一途径，其他所有交易都是转账交易）
    - 最开始是 50 个比特币、每 210000 个区块减半

17. hash rate：得到记账权的节点的算力

18. 因此避免了 sybil attack ，创建账户并不会使得你有更多的记账权

19. 比特币争夺记账权的过程就是挖矿（mining），争夺记账权的节点叫做矿工（miner）

## 05 比特币系统的具体实现

0. ledger：账本

1. 系统上没有显式地记录账户余额，只有交易记录（需要通过交易记录来计算余额）

1. transaction-based ledger：比特币的全节点需要维护一个 UTXO（unspent transaction output）集合

   - 就是所有未被花费的交易输出
   - 注意：一个交易可能会有多个输出，但是只有被花费的输出才会从 UTXO 集合中删除（所以同一个交易中、有些币在 UTXO 集合中、有些币不在）
   - 需要给出产生这个输出的交易的哈希值和它在这个交易里是第几个输出（output index），就可以定位到 UTXO 中的输出
   - UTXO 的作用：为了监测 double spending（因为只有 UTXO 集合中的币才是有效的，所以只要检查这个交易的输入是否在 UTXO 集合中就可以了）
   - 全节点需要在内存中维护这个 UTXO 集合，以便快速验证交易的有效性
   - 交易会产生新的 UTXO，也会消耗掉一些 UTXO 的内容（如果不交易、就会永久留在 UTXO 集合中，但是足够存在一个服务器的内存中的）
   - 每个服务器 total inputs = total outputs
   - 同时，有记账权的节点还能获取手续费（防止只处理自己的交易）
   - 这种的隐私保护性比较好（所以在交易的时候需要说明币的来源，有额外的代价）

1. 还有 account-based ledger：以太坊（系统中需要显式地记录账户余额）

1. block 解读

   - difficulty：每隔 210000 个区块、会调整一次难度目标（difficulty target），保证出块时间是 10 分钟左右
   - nonce：随机数，这里显示的是挖矿时找到的随机数
   - hash：区块头的哈希值（只包括块头）（符合难度要求的 hash，它的块头都包含一长串的 0）
   - merkle root：这个区块中构成的交易的根的哈希值
   - 为了找到满足要求的哈希值、需要不断地尝试不同的 nonce（挖矿的过程）
   - 但是只改变 nonce 还是不够的，所以可以更改根哈希值（time 也可以在小范围内更改）

1. 更改根哈希值的方法：

   - 通过 CoinBase 里的交易，可以在交易中加入一些额外的信息，这个信息不会影响交易的有效性，但是会影响到根哈希值（什么都可以写）
   - 最后是有两层循环的、搜索空间是 2^96，通过 nounce+coinbase 里的 extra nounce

1. Transaction 解读

   - 交易是通过脚本的形式去实现的，即把 Input Scripts 和 Output Scripts 放在一起，然后执行这个脚本，如果能够配对成功、那么这个交易就是有效的
   - 注意：不是同一个交易里的输入脚本和输出脚本配对，是当前的输入脚本和前一个节点的输出脚本进行配对（要能够顺利执行），当前的输出脚本和下一个节点的输入脚本进行配对

1. 挖矿的分析：

   - 就是不断地尝试不同的 nonce，直到找到一个满足要求的哈希值
   - 每次尝试 nonce 可以看作是一个 Bernoulli trial（a random experiment with binary possible outcomes）
   - 多次尝试，构成了一个 Bernoulli process（a sequence of independent Bernoulli trials）
   - Bernoulli process 的特点：无记忆性（memoryless），即每次尝试的结果都是独立的，不受之前的影响
   - 挖矿的场景下、可以用泊松过程（Poisson process）来模拟这个过程
   - 因此，出块时间是服从指数分布的（exponential distribution）
   - 所以是 progress free 的，不会因为之前做的工作越多、而对之后的工作有影响（否则算力强的矿工会有不成比例的优势，就是 10：1 的算力，可能会超过 10 倍的几率）（挖矿公平性的保证）
   - 由于这个挖矿的公式，系统中总共的总量是有限的，是 2100 0000 个比特币
   - 比特币的难度是人为地减少的、而不是为了解决什么数学问题，本身是没有什么实际意义的、但是挖矿的过程是对比特币的系统和机制的维护是至关重要的（Bitcoin is secured by mining）即这个过程是为了保证大部分的节点都是好的、都在诚实的人手中

1. 但是这种方案也不能保证这个记账权全部都不在恶意节点上

   - 所以最后相当于是，只需要诚实的节点都认这个交易（即沿着合法的区块往后挖，因为要扩展最长合法链）、如果这个交易只在恶意的节点上被认可、也是没有用的
   - 同时，对攻击者来说、这种新加入非法交易的区块是不会被认可的、攻击者还会因此丢掉这些比特币

1. 预防 fork attack：

   - 挖矿之前就需要指定前一个区块、然后最后的 hash 就是这个区块的 hash
   - 一种简单的方法就是多等几个确认（confirmation）（比如默认的是等 6 个区块确认，才认为前面那个交易是不可篡改的）
   - 这种不可篡改性也是一种概率的保证

1. 还有一个 zero confirmation，就是不用等到这个交易写到区块链上，就可以认为这个交易是有效的。（因为这个接受是按照时间上的最先接受的为准的，而且比特币系统以外、如果商家发现这个币是转到了无效的区块上、就可以不发货）

1. 如何反制这个区块不接受交易写入呢：通过手续费的逻辑，会总归写到一个后续的诚实的节点中去

1. selfish mining：正常是挖到一个区块、就发布了、但是有一种攻击方式、就是挖到一个区块、但是不发布、等到挖了多个区块时、然后就可以做 forking attack 了（但是这么做有一个前提、就是有恶意的节点要占用很大一部分的算力）

   - 还有一种 selfish mining 的得利：就是可以让别人沿着原来的区块继续挖、然后可以让挖得慢的人都白挖了（但是需要风险、而且需要很大的算力，但是回报也不是很高）

## 06 比特币网络的工作原理

1. The BitCoin Network:

   - 应用层（application layer）：比特币协议（Bitcoin protocol）
   - 网络层（network layer）：P2P Overlay Network（所有节点都是平等的）（有的 P2P 有 super node 或者是 master node，但是比特币没有）
     - 如果要加入这个网络、需要至少知道有一个种子节点（seed node），通过 tcp 连接、有利于穿透防火墙
     - 离开的时候直接退出就可以了、别的节点听不到你的消息、会自动从节点列表中删除

2. 比特币网络的设计原则：

   - 简单、鲁棒、而不是高效
   - 消息传播在网络中采用 flooding 的方式（即一个节点收到消息之后、会广播给所有的节点），下一次收到相同的消息时、就不会再转发了
   - 邻居节点的设定是随机的、没有拓扑结构的、就是不按照地理位置组合。这样可以增强系统的鲁棒性，因此给你身边的人转账和给远处的人转账是一样的）
   - 等待写入区块链的交易会写入一个集合中、下一次听到这个交易的时候就不转发了、避免了无限转发

3. race condition

   - 有 A->B 和 A->C 两个交易、但是用了相同的币，只能有一个能够写入区块链
   - 如果一个节点听到了 A->B 或者 A->C 已经被写入其他的区块链了，那么就会把这个交易从集合中删除

4. 比特币网络的特性：

   - 区块的传播和交易是类似的
   - 越大的区块在网络中传播的时间越慢（限制是 1MB，因为带宽是瓶颈）
   - 是 best effort 的：不保证消息一定能够传播到所有的节点，顺序也不一定是一样的（而且有些节点可能不转发，就是去中心化的网络中会遇到的问题）
   - 无法支持中心化的投诉
   - 回滚的解决方法：通过两个不同的交易，而不是数据层面的回滚（就是转账和退款的两个交易）

## 07 挖矿难度

1. H(block header) <= target

   - target 越小、挖矿难度越大
   - 调整挖矿难度就是调整整个挖矿空间在输出空间中的比例
   - 使用 SHA-256 哈希函数（整个输出空间是 2^256）
   - 调整：就是要求算出来的哈希 H 前面的 0 的个数越多、难度越大
   - 挖矿难度（difficulty）和 target 是反比的关系
   - difficulty = difficulty_1_target / target（difficulty_1_target 指的是挖矿难度为 1 的时候的目标阈值 target，难度最小就是 1）

2. 调整挖矿难度的原因：因为比特币的算力是在不断增加的，所以需要调整难度，保证出块时间是 10 分钟

   - 如果出块时间太短： 因为区块在网络上传播就至少需要几十秒、如果在几秒钟同时出了多个区块、就会有分叉的问题（而且不止是二分叉，可能是多分叉）
   - 分叉如果过多的话、对系统的安全性是有影响的（分叉攻击，降低了分叉攻击所需要的算力百分比），对达成共识也是有影响的
   - 也不是一定要 10 分钟出块时间，只不过需要一个常数范围内的时间（比如 10 分钟左右）
   - 以太坊的出块速度就很快，是 15 秒一个区块（不过也需要调整难度以保持稳定）

3. 具体怎么调整挖矿难度：

   - 每 2016 个区块调整一次（大概是 2 周）（2016\*10/60/24 = 14 天）
   - 调整公式：target = target \* (actual time / expected time)（actual time 是实际的时间，就是系统中最近产生 2016 个区块实际经过的区间，expected time 是预期的时间，就是 2016\*10min = 2 周）（会实际提高或降低 target，以保证实际的出块时间和预期的出块时间一致，最高最低这个倍数有 4 倍的限制）
   - 如果恶意的区块不调整难度的话、那么诚实的矿工不会认这个区块节点（无法通过区块的合法性）

4. 比特币是没有法币背书的，而且选择的参数也是比较保守的，也是经验公式

5. 比特币系统中的实际情况

   - 总算力指数增长（体现在 hash rate 和时间的关系上）
   - 挖矿难度和总算力是正相关的（因为挖矿难度是根据总算力来调整的，使得出块时间是稳定的）
   - 如果挖矿难度 difficulty 是不断减少的、那么这个币一般来说就要很快不行了
   - 每天的出块时间都是稳定的、维持在 10 分钟左右
   - 挖矿难度和目标阈值是反比的关系（公式可能会混淆）

## 08 比特币挖矿
